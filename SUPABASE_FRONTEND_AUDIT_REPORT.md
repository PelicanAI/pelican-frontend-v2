# Supabase Frontend Database Interactions Audit Report

**Generated:** 2024  
**Scope:** All Supabase database interactions in the Next.js/TypeScript frontend  
**Purpose:** Comprehensive mapping of frontend-backend data flows and potential mismatches

---

## Executive Summary

This audit identifies **8 Supabase tables** directly accessed by the frontend, **2 memory tables** used for backend integration, and **multiple data flow patterns** that require coordination between frontend and backend systems.

**Key Findings:**
- ✅ Frontend uses RLS-safe helper functions for UPDATE/DELETE operations
- ⚠️ **CRITICAL:** Frontend reads from `memory_conversations` and `memory_messages` tables (backend-managed)
- ⚠️ **POTENTIAL MISMATCH:** Conversation IDs may differ between `conversations` (frontend) and `memory_conversations` (backend)
- ⚠️ **DUAL PERSISTENCE:** Messages are saved by backend, but frontend also queries `messages` table directly
- ✅ File uploads use Supabase Storage with metadata in `files` table
- ✅ Real-time subscriptions only for `conversations` table (not `messages`)

---

## 1. Table References Summary

| Table Name | Operations | Location | Client/Server | Notes |
|------------|-----------|----------|--------------|-------|
| `conversations` | SELECT, INSERT, UPDATE, DELETE | Multiple | Both | Main conversation table |
| `messages` | SELECT, UPDATE | Multiple | Server (API routes) | Backend writes, frontend reads |
| `memory_conversations` | SELECT | API route | Server | Backend-managed memory system |
| `memory_messages` | SELECT | API route | Server | Backend-managed memory system |
| `files` | SELECT, INSERT, UPDATE, DELETE | Multiple | Server (API routes) | File metadata |
| `user_settings` | SELECT, UPSERT, DELETE | Settings page | Client & Server | User preferences |
| `profiles` | SELECT | Profile page | Server | User profile data |
| `user_analytics` | SELECT | Profile page | Server | Usage statistics |
| `pelican` (Storage) | UPLOAD, REMOVE, CREATE_SIGNED_URL | Upload route | Server | File storage bucket |

---

## 2. Detailed Table Analysis

### 2.1 `conversations` Table

**Operations:**
- **SELECT:** List conversations, get single conversation
- **INSERT:** Create new conversation
- **UPDATE:** Rename, archive, soft-delete
- **DELETE:** Hard delete (via helper)

**Locations:**

#### Client-Side (Direct Supabase):
```typescript
// hooks/use-conversations.ts:224
.from("conversations")
.select("*")
.eq("user_id", userId)
.is("deleted_at", null)
.order("updated_at", { ascending: false })
```

#### Server-Side (API Routes):
```typescript
// app/api/conversations/route.ts:25
.from("conversations")
.select(`id, title, created_at, updated_at, message_count, last_message_preview, archived, archived_at, deleted_at`)
.eq("user_id", user.id)
.is("deleted_at", null)
```

**Columns Accessed:**
- `id` (UUID, primary key)
- `user_id` (UUID, foreign key to auth.users)
- `title` (TEXT)
- `created_at` (TIMESTAMP)
- `updated_at` (TIMESTAMP)
- `message_count` (INTEGER)
- `last_message_preview` (TEXT)
- `archived` (BOOLEAN)
- `archived_at` (TIMESTAMP, nullable)
- `deleted_at` (TIMESTAMP, nullable)

**ID Format:**
- **Generated by:** Database (`gen_random_uuid()`)
- **Format:** UUID v4
- **Frontend expectation:** UUID string
- **Guest mode:** Frontend generates `guest-${timestamp}-${random}` format (NOT UUID)

**Real-time Subscription:**
```typescript
// hooks/use-conversations.ts:201-213
supabase
  .channel(`conversations:${user.id}`)
  .on("postgres_changes", {
    event: "*",
    schema: "public",
    table: "conversations",
    filter: `user_id=eq.${user.id}`
  }, () => loadFromDatabase(user.id))
  .subscribe()
```

---

### 2.2 `messages` Table

**Operations:**
- **SELECT:** Load conversation messages
- **UPDATE:** Regenerate message content

**Locations:**

#### Server-Side Only (API Routes):
```typescript
// app/api/conversations/[id]/messages/route.ts:37
.from('memory_messages')  // NOTE: Uses memory_messages, not messages!
.select('id, role, content, created_at')
.eq('conversation_id', conversation.id)
.eq('user_id', user.id)
.order('created_at', { ascending: true })
```

**⚠️ CRITICAL FINDING:** The messages route queries `memory_messages`, NOT `messages` table!

**Columns Accessed:**
- `id` (UUID)
- `conversation_id` (UUID, foreign key)
- `role` (TEXT: 'user' | 'assistant' | 'system')
- `content` (TEXT)
- `created_at` (TIMESTAMP)
- `user_id` (UUID, for filtering)

**ID Format:**
- **Generated by:** Backend (FastAPI) or Database
- **Format:** UUID v4 (database) or custom format (backend)
- **Frontend expectation:** UUID string or `msg_${timestamp}_${random}` format

**⚠️ NO Real-time Subscription:** Messages are NOT subscribed to real-time updates (intentional - prevents conflicts with streaming)

---

### 2.3 `memory_conversations` Table

**Operations:**
- **SELECT:** Lookup conversation by session_id

**Locations:**
```typescript
// app/api/conversations/[id]/messages/route.ts:19-24
.from('memory_conversations')
.select('id, user_id, session_id')
.eq('session_id', conversationId)  // Frontend conversation ID
.eq('user_id', user.id)
.single()
```

**Purpose:** Maps frontend `conversation_id` (session_id) to backend internal `id`

**⚠️ CRITICAL:** This table bridges frontend conversation IDs with backend memory system IDs

**Columns:**
- `id` (Internal backend ID)
- `user_id` (UUID)
- `session_id` (String - matches frontend conversation_id)

---

### 2.4 `memory_messages` Table

**Operations:**
- **SELECT:** Fetch messages for a conversation

**Locations:**
```typescript
// app/api/conversations/[id]/messages/route.ts:37-41
.from('memory_messages')
.select('id, role, content, created_at')
.eq('conversation_id', conversation.id)  // Uses internal ID from memory_conversations
.eq('user_id', user.id)
.order('created_at', { ascending: true })
```

**⚠️ CRITICAL:** Messages are stored in `memory_messages`, NOT `messages` table!

**Columns:**
- `id` (UUID)
- `conversation_id` (UUID - references memory_conversations.id, NOT conversations.id)
- `role` (TEXT)
- `content` (TEXT)
- `created_at` (TIMESTAMP)
- `user_id` (UUID)

---

### 2.5 `files` Table

**Operations:**
- **SELECT:** Get files by conversation, user, or checksum
- **INSERT:** Create file record after upload
- **UPDATE:** Mark file as claimed by conversation
- **DELETE:** Remove file record

**Locations:**

#### Server-Side (Service Role):
```typescript
// lib/files.ts:67-73
.from("files")
.select("*")
.eq("checksum", checksum)
.eq("mime", mime)
.eq("size", size)
.single()
```

**Columns:**
- `id` (UUID)
- `user_id` (UUID, nullable)
- `guest_id` (UUID, nullable)
- `conversation_id` (UUID, nullable)
- `storage_key` (TEXT) - Path in Supabase Storage
- `mime` (TEXT) - MIME type
- `size` (INTEGER) - File size in bytes
- `checksum` (TEXT) - SHA256 hash for deduplication
- `created_at` (TIMESTAMP)

**Storage Bucket:** `pelican` (Supabase Storage)

---

### 2.6 `user_settings` Table

**Operations:**
- **SELECT:** Get user settings
- **UPSERT:** Save user settings
- **DELETE:** Clear on account deletion

**Locations:**
```typescript
// app/settings/page.tsx:156
.from("user_settings")
.select("*")
.eq("user_id", user!.id)
.single()
```

**Columns:** (JSONB or individual columns - structure varies)
- `user_id` (UUID, primary key)
- `display_name`, `email`, `avatar_url`
- `default_timeframes`, `preferred_markets`, `risk_tolerance`
- `email_notifications`, `market_alerts`, `price_alerts`
- `auto_scroll`, `message_density`, `show_timestamps`
- `theme`, `sidebar_collapsed_default`, `market_panel_visible`, `font_size`
- `updated_at` (TIMESTAMP)

---

### 2.7 `profiles` Table

**Operations:**
- **SELECT:** Get user profile

**Locations:**
```typescript
// app/profile/page.tsx:21
.from("profiles")
.select("*")
.eq("id", user.id)
.single()
```

**Columns:**
- `id` (UUID, references auth.users)
- `display_name` (TEXT)
- `email` (TEXT)
- `created_at` (TIMESTAMP)

---

### 2.8 `user_analytics` Table

**Operations:**
- **SELECT:** Get user statistics

**Locations:**
```typescript
// app/profile/page.tsx:24
.from("user_analytics")
.select("*")
.eq("user_id", user.id)
.single()
```

**Columns:**
- `user_id` (UUID, primary key)
- `total_messages` (INTEGER)
- `total_conversations` (INTEGER)
- `last_active` (TIMESTAMP)

---

## 3. Critical Data Flows

### 3.1 Create Conversation

**Flow:**
1. **Frontend Hook:** `useConversations().create()`
2. **Location:** `hooks/use-conversations.ts:243-301`
3. **Method:**
   - **Authenticated:** Direct Supabase INSERT
   - **Guest:** localStorage only

**Code:**
```typescript
// Authenticated user
const { data, error } = await supabase
  .from("conversations")
  .insert({ user_id: userId, title })
  .select()
  .single()
```

**ID Generation:**
- **Database:** `gen_random_uuid()` (UUID v4)
- **Guest:** `guest-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`

**Backend Integration:**
- ❌ **NOT called** - Frontend creates conversation directly in Supabase
- ⚠️ **POTENTIAL ISSUE:** Backend may create `memory_conversations` entry separately when first message is sent

---

### 3.2 Send Message

**Flow:**
1. **Frontend Hook:** `useChat().sendMessage()`
2. **Location:** `hooks/use-chat.ts:432-437` → `hooks/use-streaming-chat.ts:170-361`
3. **Method:** Direct fetch to backend API (NOT Supabase)

**Backend API Call:**
```typescript
// hooks/use-streaming-chat.ts:241
const response = await fetch(`${BACKEND_URL}/api/pelican_stream`, {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    ...(token && { 'Authorization': `Bearer ${token}` }),
  },
  body: JSON.stringify({
    message: string,
    conversationHistory: Array<{role: string, content: string}>,
    conversation_history: Array<{role: string, content: string}>, // Duplicate for compatibility
    conversationId: string | null,
    files: string[],
    timestamp: string,
    stream: true,
  }),
})
```

**Backend Endpoint:** `https://pelican-backend.fly.dev/api/pelican_stream`

**Response Format (SSE Stream):**
```
data: {"delta": "chunk", "type": "chunk"}
data: {"type": "done", "conversation_id": "uuid", "session_id": "uuid"}
```

**Message Persistence:**
- ✅ **Backend handles** - Messages saved to `memory_messages` by backend
- ❌ **Frontend does NOT** write to `messages` table directly
- ⚠️ **Optimistic UI:** Frontend adds message to local state immediately

**Conversation ID Handling:**
- If `conversationId` is null, backend creates new conversation
- Backend returns `conversation_id` or `session_id` in done event
- Frontend captures this and updates local state

---

### 3.3 Load Conversation History

**Flow:**
1. **Frontend Hook:** `useChat().loadMessages()`
2. **Location:** `hooks/use-chat.ts:218-301`
3. **Method:** Fetch from Next.js API route

**API Route:**
```typescript
// app/api/conversations/[id]/messages/route.ts
GET /api/conversations/{conversationId}/messages
```

**Backend Query:**
```typescript
// Step 1: Lookup memory_conversations by session_id
const { data: conversation } = await supabase
  .from('memory_conversations')
  .select('id, user_id, session_id')
  .eq('session_id', conversationId)  // Frontend conversation ID
  .eq('user_id', user.id)
  .single()

// Step 2: Fetch messages using internal ID
const { data: messages } = await supabase
  .from('memory_messages')
  .select('id, role, content, created_at')
  .eq('conversation_id', conversation.id)  // Internal ID
  .eq('user_id', user.id)
  .order('created_at', { ascending: true })
```

**⚠️ CRITICAL:** 
- Frontend `conversationId` must match `memory_conversations.session_id`
- Messages are fetched from `memory_messages`, NOT `messages` table
- Uses internal `memory_conversations.id` for message lookup

**Response Format:**
```typescript
{
  messages: Array<{
    id: string,
    role: 'user' | 'assistant' | 'system',
    content: string,
    created_at: string
  }>,
  conversationId: string
}
```

---

### 3.4 Display Chat List / Sidebar

**Flow:**
1. **Frontend Hook:** `useConversations()`
2. **Location:** `hooks/use-conversations.ts:120-543`
3. **Method:** Direct Supabase query OR localStorage (guest mode)

**Query:**
```typescript
// hooks/use-conversations.ts:223-228
const { data, error } = await supabase
  .from("conversations")
  .select("*")
  .eq("user_id", userId)
  .is("deleted_at", null)
  .order("updated_at", { ascending: false })
```

**Real-time Updates:**
- ✅ Subscribed to `conversations` table changes
- Updates list when conversation is created/updated/deleted

**Filtering:**
- Client-side filtering by `archived` status
- Client-side search by `title` or `last_message_preview`

---

### 3.5 File Uploads

**Flow:**
1. **Frontend Hook:** `useFileUpload().handleFileUpload()`
2. **Location:** `hooks/use-file-upload.ts:30-112`
3. **Method:** POST to Next.js API route

**API Route:**
```typescript
// app/api/upload/route.ts
POST /api/upload
Content-Type: multipart/form-data
Body: { file: File }
```

**Upload Process:**
1. **Validate:** MIME type, size (25MB max), magic bytes
2. **Compute Checksum:** SHA256 hash
3. **Check Deduplication:** Query `files` table by checksum
4. **Upload to Storage:** Supabase Storage bucket `pelican`
5. **Create File Record:** INSERT into `files` table
6. **Generate Signed URL:** 7-day expiration

**Storage Path Format:**
```
{year}/{month}/{uuid}.{extension}
```

**File Record:**
```typescript
{
  user_id: string,
  storage_path: string,  // Note: column name is storage_path, not storage_key
  mime_type: string,
  name: string,
  size: number
}
```

**⚠️ COLUMN NAME MISMATCH:**
- Upload route uses `storage_path` (line 258)
- Files helper uses `storage_key` (lib/files.ts:27)
- **Potential bug:** Check if these are the same column or different

**File Association:**
- Files are uploaded BEFORE message is sent
- File IDs are passed in `files` array to backend API
- Backend associates files with conversation

---

## 4. TypeScript Types Analysis

### 4.1 Conversation Type

**Definition:**
```typescript
// hooks/use-conversations.ts:28-37
export interface Conversation {
  id: string
  title: string
  created_at: string
  updated_at: string
  message_count: number
  last_message_preview: string
  user_id: string
  archived?: boolean
}
```

**Usage Locations:**
- `hooks/use-conversations.ts` - Main hook
- `components/chat/conversation-sidebar.tsx` - Sidebar display
- `components/chat/chat-sidebar.tsx` - Alternative sidebar

**Database Schema Match:**
- ✅ Matches `conversations` table columns
- ⚠️ Missing: `archived_at`, `deleted_at` (optional fields)

---

### 4.2 Message Type

**Definition:**
```typescript
// lib/chat-utils.ts:1-11
export interface Message {
  id: string
  role: "user" | "assistant" | "system"
  content: string
  timestamp: Date
  isStreaming?: boolean
  isPinned?: boolean
  isEdited?: boolean
  attachments?: Attachment[]
  retryAction?: () => void
}
```

**Usage Locations:**
- `hooks/use-chat.ts` - Main chat hook
- `components/chat/chat-container.tsx` - Message display
- `components/chat/message-bubble.tsx` - Individual message
- Multiple other chat components

**Database Schema Match:**
- ⚠️ **MISMATCH:** Frontend uses `timestamp: Date`, database uses `created_at: string`
- ⚠️ **MISMATCH:** Frontend has `isStreaming`, `isPinned`, `isEdited` (UI-only, not in DB)
- ⚠️ **MISMATCH:** Frontend has `attachments`, database may store differently
- ✅ `role` matches database enum
- ✅ `content` matches database TEXT

**ID Format:**
- Frontend generates: `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
- Database expects: UUID v4
- ⚠️ **POTENTIAL MISMATCH:** Frontend message IDs may not match database IDs

---

### 4.3 FileRecord Type

**Definition:**
```typescript
// lib/files.ts:22-32
export interface FileRecord {
  id: string
  user_id: string | null
  guest_id: string | null
  conversation_id: string | null
  storage_key: string
  mime: string
  size: number
  checksum: string
  created_at: string
}
```

**Database Schema Match:**
- ⚠️ **COLUMN NAME CHECK NEEDED:** `storage_key` vs `storage_path` (see File Uploads section)

---

## 5. ID Format Analysis

### 5.1 user_id

**Source:**
- Supabase Auth: `supabase.auth.getUser()` → `user.id`
- Format: UUID v4
- Validation: `isValidUUID()` helper function

**Usage:**
- All queries filter by `user_id`
- RLS policies enforce `auth.uid() = user_id`
- Guest mode: Generated UUID stored in localStorage

**Validation:**
```typescript
// lib/supabase/helpers.ts:52-56
export function isValidUUID(str: string | null | undefined): boolean {
  if (!str) return false
  const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i
  return uuidRegex.test(str)
}
```

---

### 5.2 conversation_id

**Format:**
- **Authenticated:** UUID v4 (database-generated)
- **Guest:** `guest-${timestamp}-${random}` (frontend-generated)

**Generation:**
- **Database:** `gen_random_uuid()` in `conversations` table
- **Frontend (guest):** `guest-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`

**Backend Mapping:**
- Frontend `conversation_id` → `memory_conversations.session_id`
- Backend uses internal `memory_conversations.id` for message lookups

**⚠️ CRITICAL FLOW:**
1. Frontend creates conversation → Gets UUID from `conversations` table
2. Frontend sends message with `conversationId` → Backend creates/updates `memory_conversations` with `session_id = conversationId`
3. Frontend loads messages → Queries `memory_conversations` by `session_id` to get internal `id`, then queries `memory_messages`

**Potential Issues:**
- If backend doesn't create `memory_conversations` entry, message loading will fail
- If `session_id` doesn't match frontend `conversation_id`, messages won't load

---

### 5.3 message_id

**Format:**
- **Frontend (temporary):** `msg_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`
- **Database:** UUID v4 (backend-generated)

**Generation:**
- **Frontend:** `lib/chat-utils.ts:39-41` - Temporary IDs for optimistic UI
- **Backend:** Database `gen_random_uuid()` when saving to `memory_messages`

**⚠️ MISMATCH:** Frontend message IDs are temporary and don't match database IDs

**Impact:**
- Frontend uses temporary IDs for UI state
- When messages are loaded from database, they get new IDs from database
- This is intentional - frontend IDs are ephemeral

---

## 6. API Calls to Backend

### 6.1 Streaming Chat Endpoint

**Endpoint:** `POST https://pelican-backend.fly.dev/api/pelican_stream`

**Request:**
```typescript
{
  message: string,
  conversationHistory: Array<{role: string, content: string}>,
  conversation_history: Array<{role: string, content: string}>, // Duplicate
  conversationId: string | null,
  files: string[],  // File IDs from files table
  timestamp: string,
  stream: true
}
```

**Response:** SSE Stream
```
data: {"delta": "chunk", "type": "chunk"}
data: {"type": "done", "conversation_id": "uuid", "session_id": "uuid"}
```

**Location:** `hooks/use-streaming-chat.ts:241`

**Authentication:** Bearer token from Supabase session

---

### 6.2 File Upload Endpoint

**Endpoint:** `POST /api/upload` (Next.js API route, not backend)

**Request:** `multipart/form-data` with `file` field

**Response:**
```typescript
{
  id: string,  // File record ID
  url: string,  // Signed URL
  key: string,  // Storage path
  name: string,
  type: string,  // MIME type
  size: number,
  checksum: string,
  public: false
}
```

**Location:** `hooks/use-file-upload.ts:70`

**Note:** This is a Next.js API route that uses Supabase Storage, NOT the FastAPI backend

---

### 6.3 Other Backend Calls

**Pelican API (Regeneration):**
- Endpoint: `https://api.pelican.ai/v1/chat/completions`
- Location: `app/api/messages/[id]/regenerate/route.ts:102`
- Purpose: Regenerate assistant message
- Note: This is a server-side API route, not direct frontend call

---

## 7. Supabase Client Configuration

### 7.1 Client-Side Client

**Location:** `lib/supabase/client.ts`

**Type:** Browser client (`createBrowserClient` from `@supabase/ssr`)

**Key:** `NEXT_PUBLIC_SUPABASE_ANON_KEY`

**Usage:**
- All client components
- Hooks that run in browser
- Real-time subscriptions

**RLS:** Enforced (uses anon key, RLS policies apply)

---

### 7.2 Server-Side Client

**Location:** `lib/supabase/server.ts`

**Type:** Server client (`createServerClient` from `@supabase/ssr`)

**Key:** `NEXT_PUBLIC_SUPABASE_ANON_KEY`

**Usage:**
- Next.js API routes
- Server components
- Server-side data fetching

**RLS:** Enforced (uses anon key, RLS policies apply)

---

### 7.3 Service Role Client

**Location:** `lib/files.ts:13-16`

**Type:** Direct client (`createClient` from `@supabase/supabase-js`)

**Key:** `SUPABASE_SERVICE_ROLE_KEY` (server-only env var)

**Usage:**
- File operations (bypasses RLS for server-to-server operations)

**RLS:** Bypassed (service role key has full access)

---

### 7.4 Real-time Subscriptions

**Active Subscriptions:**
- `conversations` table changes (user-specific filter)
- Location: `hooks/use-conversations.ts:201-213`

**NOT Subscribed:**
- `messages` table (intentional - prevents conflicts with streaming)
- `memory_messages` table
- `files` table

---

## 8. Potential Race Conditions

### 8.1 Conversation Creation vs Message Sending

**Scenario:**
1. Frontend creates conversation → Gets UUID
2. Frontend immediately sends message with conversationId
3. Backend may not have created `memory_conversations` entry yet

**Risk:** Medium  
**Mitigation:** Backend should handle missing `memory_conversations` entry by creating it

---

### 8.2 Optimistic UI Updates

**Scenario:**
1. Frontend adds message to local state (optimistic)
2. Backend streams response
3. Frontend updates message content as chunks arrive
4. If backend fails, frontend message remains in state

**Risk:** Low  
**Mitigation:** Error handling removes failed messages

---

### 8.3 Real-time Updates vs Manual Refresh

**Scenario:**
1. User A creates conversation → Real-time subscription fires for User A
2. User B (same account, different device) doesn't see it until refresh
3. Or: Real-time update arrives while user is manually refreshing

**Risk:** Low  
**Mitigation:** Real-time subscription triggers reload, which is idempotent

---

### 8.4 File Upload vs Message Send

**Scenario:**
1. User uploads file → Gets file ID
2. User sends message with file ID
3. Backend may not have access to file yet (signed URL expiration)

**Risk:** Low  
**Mitigation:** Signed URLs have 7-day expiration, files are associated immediately

---

## 9. Frontend/Backend Mismatches

### 9.1 Conversation ID Mapping

**Issue:** Frontend uses `conversations.id` (UUID), backend uses `memory_conversations.session_id` (string)

**Impact:** 
- Messages route must lookup `memory_conversations` by `session_id`
- If backend doesn't create mapping, messages won't load

**Status:** ⚠️ **REQUIRES COORDINATION**

---

### 9.2 Message Storage Location

**Issue:** 
- Frontend queries `memory_messages` table
- But may also expect `messages` table to exist

**Impact:**
- If backend only writes to `memory_messages`, frontend queries are correct
- If backend also writes to `messages`, there may be duplicate storage

**Status:** ⚠️ **VERIFY BACKEND BEHAVIOR**

---

### 9.3 Message ID Format

**Issue:** Frontend generates temporary IDs (`msg_${timestamp}_${random}`), database uses UUIDs

**Impact:** 
- Frontend IDs are ephemeral (for optimistic UI)
- Database IDs are permanent
- When messages are loaded, they get database IDs

**Status:** ✅ **INTENTIONAL** - Not a bug

---

### 9.4 File Storage Column Name

**Issue:** 
- Upload route uses `storage_path` column
- Files helper uses `storage_key` property

**Impact:** 
- Potential column name mismatch
- May cause file lookup failures

**Status:** ⚠️ **VERIFY COLUMN NAME**

---

### 9.5 Conversation History Field Names

**Issue:** Frontend sends both `conversationHistory` (camelCase) and `conversation_history` (snake_case)

**Impact:** 
- Backend may expect one or the other
- Frontend sends both for compatibility

**Status:** ✅ **INTENTIONAL** - Compatibility measure

---

## 10. Recommendations

### 10.1 High Priority

1. **Verify `memory_conversations` Creation:**
   - Ensure backend creates `memory_conversations` entry when first message is sent
   - Ensure `session_id` matches frontend `conversation_id`

2. **Verify File Column Name:**
   - Check if `files` table uses `storage_path` or `storage_key`
   - Update code to use consistent name

3. **Document Message Storage:**
   - Clarify if messages are stored in `memory_messages` only, or also in `messages`
   - Update frontend queries accordingly

### 10.2 Medium Priority

1. **Type Safety:**
   - Add TypeScript types for `memory_conversations` and `memory_messages`
   - Ensure Conversation type includes all optional fields

2. **Error Handling:**
   - Add error handling for missing `memory_conversations` entries
   - Add fallback for message loading failures

3. **ID Validation:**
   - Validate conversation IDs before querying
   - Handle guest conversation IDs differently

### 10.3 Low Priority

1. **Code Cleanup:**
   - Remove duplicate `conversationHistory` / `conversation_history` fields (once backend standardizes)
   - Consolidate file column name usage

2. **Documentation:**
   - Document the conversation ID mapping flow
   - Document message ID lifecycle (temporary → permanent)

---

## 11. Summary Table: Frontend vs Backend Expectations

| Aspect | Frontend Expects | Backend Provides | Status |
|--------|-----------------|------------------|--------|
| Conversation ID | UUID from `conversations.id` | `memory_conversations.session_id` | ⚠️ Requires mapping |
| Message Storage | `memory_messages` table | `memory_messages` table | ✅ Matches |
| Message ID | Temporary `msg_*` format | UUID from database | ✅ Intentional |
| File Storage | `files` table + `pelican` bucket | Same | ✅ Matches |
| User ID | UUID from Supabase Auth | UUID from Supabase Auth | ✅ Matches |
| Conversation History | Array of `{role, content}` | Same format | ✅ Matches |
| Real-time Updates | `conversations` table only | N/A (frontend-only) | ✅ Matches |

---

## Appendix: File Locations Reference

### Supabase Client Creation
- Client: `lib/supabase/client.ts`
- Server: `lib/supabase/server.ts`
- Service Role: `lib/files.ts:13-16`

### Main Hooks
- Conversations: `hooks/use-conversations.ts`
- Chat: `hooks/use-chat.ts`
- Streaming: `hooks/use-streaming-chat.ts`
- File Upload: `hooks/use-file-upload.ts`

### API Routes
- Conversations List: `app/api/conversations/route.ts`
- Single Conversation: `app/api/conversations/[id]/route.ts`
- Messages: `app/api/conversations/[id]/messages/route.ts`
- Upload: `app/api/upload/route.ts`
- Regenerate: `app/api/messages/[id]/regenerate/route.ts`

### Helper Functions
- RLS Helpers: `lib/supabase/helpers.ts`
- File Operations: `lib/files.ts`
- Types: `lib/chat-utils.ts`

---

**End of Audit Report**

